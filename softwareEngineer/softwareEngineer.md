---
title: 2017-9-29未命名文件 
tags: 软件工程,课程笔记,王安生
grammar_cjkRuby: true
---

## Course2
### 2.1
#### 2.1.3 硬件的连续性

1. 固件：软件和硬件的结合体
2. 连续系统：

	* 至少是一阶可导的，or
	* 多阶可导函数

#### 2.1.4 软件的离散性
1. 离散系统又可分为两类：时间离散和事件离散

	事件离散：系统接收系统外接的某个或多个事件，从而引起当前系统的状态发生变化
#### 	2.1.5 人的特性与管理
#### 2.1.6 固件与嵌入式系统
1. 固件是指写入到EROM或者EPROM中的程序及其数据，通俗的理解就是固化的硬件
2. 网络能够让固件接入互联网
3. 硬件的故障特征：在磨合期和老化期是最容易出错的。中间有较长的稳定工作期。
4. 硬件系统装配成系统的故障特性：设计师期望关键部件在系统的使用寿命内不要更换
5. 全生命周期设计
6. 硬件生产质量的统计学控制中间线是理想质量线或者期望质量，其他两条虚线表示偏差的上线和下线。
7. 软件故障的表现和分类：

	* **计算机除零错误**
	* **指向内存地址的指针超出规定的内存范围**
	* **整型数向上或者向下溢出**
	* **浮点数向上或者向下溢出**
	* 计算类错误（CO）
	* 逻辑错误(LO)
	* 操作错误(OP)
	* 需求不准确(RI)
	* 数据处理错误(DH)
	* 设计错误(DE)
	* 接口错误(IN)
	* 书写错误(CL)
	* 数据库错误(DB)
8. 程序正确性证明：还没有办法证明任何一个程序是否正确
9. 测试的充分性问题：企图通过测试证明软件的正确是徒劳的，测试可以表明软件缺陷的存在而不是不存在
10. 代码复用：重复使用经过运行考验的软件部件
11. 部件组装：
12. 软件开发理念
	* 减低修改频率，控制变更
	* 降低部件之间的耦合度 
	* 区分需求稳定性
	* 复用
	* 充分（回归）测试:一旦对某个部件进行修改，就必须对整个系统进行充分测试
	* 过程质量控制
13. 操作员的错误
	* 配置错误：
	* 规程错误
	* 其他错误

14. 人的信息处理模型

	* 传感信息储存
	* miss

15. 瑞士奶酪原理：分层管理
16. 错误预防措施

	* 操作者：将错误看做是操作者的责任，避免人的“不安全行文和动作”
	* 系统设计：假设人是会犯错误的
	* 运行和操作规程
	* 缺陷预防体系

## Chapter 3 软件开发过程
### 3.1 程序开发基本过程
#### 3.1.1 一个简单的程序开发的例子
#### 3.1.2 程序开发库和复用

### 3.2 从程序开发到软件工程化过程
#### 3.2.1 软件开发的活动
#### 3.2.2 大型软件开发的管理

### 3.3 中间产品驱动的过程
#### 3.3.1 中间产品驱动的过程
#### 3.3.2 中间产品的意义
1. 中间产品质量是最终产品质量的依据.
2. 中间产品的另一个作用是增加工作的复用.
3. 中间产品可以极大地降低返工工作量

### 3.4 瀑布式还是迭代式
#### 3.4.0 瀑布模型特征

#### 3.4.1 增量式模型
1. ==增量式(incremental)==:是指在开发过程中,先实现那些需求明确的增量.随着系统开发进展,人们会对一些需求不明确的需求逐渐清晰起来,那么会在后续的第二次第三次迭代中,更容易的实现这些需求功能.
#### 3.4.2 渐进式模型
1. ==渐进式(evolutional)==:也需要多次迭代的过程
2. 首先开发原型,根据用户反馈,不断开发新的原型
3. 渐进是一个保持稳定性的技能.
4. 缺点:缺少过程的可见性,系统通常不能够很好的结构化,可能需要特殊的技巧(快速原型语言)
4. 适用于中小规模的交互式系统,大系统的一部分或者生命周期短的系统 
#### 3.4.3 螺旋式模型
1. ==螺旋式==:基本与渐进式开发一样,不同的是                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
### 3.5 软件产品的开发过程
#### 3.5.1 策略和原则的建立
#### 3.5.2 定义产品和开发过程xing
1. 通过进化特征和固定资源,集中创新性
#### 3.5.3 开发产品与装箱
#### 3.5.4 与黑客方法的差别
#### 3.5.5 方法的优点

### 3.6 计算机辅助与模型驱动的软件工程
### 3.7 本章小结
## Chapter 4 软件质量
#### 4.1.1 程序的类型划分
1. P-型程序：
2. E-型程序：
3. S-型程序：特性唯一，可证明其正确性
4. CS类型：客户满意
5. ZD类型：高可信，安全
6. SV类型：大型消费和市场竞争
7. 软件的质量定义为：满足给定需要的性质和特性的总体

### 4.2 质量观点
#### 4.2.1 Garvin的质量分类
1. 先验质量观点
2. 基于产品的质量观点
3. 基于用户的质量观点：质量就是用户眼里所看到的。最大化的满足不同客户的要求。其他不同的解释：1.满足的客户的数量大 2. 满足客户独特的需求
4. 基于制造的质量观点：认为“质量是产品与需求的符合程度”，而设计决定了符合程度
5. 基于经济的质量观点：

#### 4.2.2 Brra
1. 技术质量侧面
2. 使用质量侧面
3. 美学质量侧面
4. 品牌质量侧面
5. 组织质量侧面
#### 4.2.3 项目经理们对质量的看法
1. 开发方的项目经理们：认为软件质量是“软件能够很好的服务用户，并完成所希望的功能，并在需要的时候可以使用”；面临着财政和时间的约束
2. 采购方的经理们
### 4.3 软件质量模型的归纳
1. 产品质量学派：认为要清楚的定义，测量和改进质量，就必须测量影响软件质量的每一个特性
2. 过程质量学派：认为最终产品取决于生产过程的质量。因此，软件质量来源于软件过程的质量。
3. 产品模型
4. 过程模型

### 4.4 ISO9126的质量定义
#### 4.4.1 软件产品质量模型 
#### 4.4.2 产品质量属性分解
1. ISO9126：
2. 功能性：
	* 发的
3. 可靠性

	* 成熟性
	* 容错性
	* 易恢复性

4. 易用性

	* 易理解性
	* 易学性
	* 易操作性
	* 吸引性

5. 效率：

	* 时间特性
	* 资源利用性

6. 维护性

	* 易分析性
	* 易修改性
	* 稳定性
	* 易测试性
	
7. 可安装性
	* 易安装性
	* 共存性
#### 4.4.3 部件和服务项的质量评价
### 4.5 总结
1. 质量归结起来主要是基于产品和基于过程质量观点。

	* 产品质量观点会定义出产品的质量度量指标。并分解到产品的外部和内部特性需求。
	* 基于过程的质量观点，希望把这些指标分解到软件开发过程中的每一个阶段的每一个活动中。并希望通过对过程管理落实质量需求。
## Chapter 5 可信赖性
### 5.1
#### 5.1.1 可信赖性的起因 
#### 5.1.2 可信赖性的定义
1. 可信赖性是指：人们对计算机系统所提供服务的信任程度
2. ISO组织将可信赖性定义为：用来描述可使用性能和与其相关的
#### 5.1.3 可信赖性的属性

#### 5.2.2 可信赖性的属性讨论。
1. 生存性和密安性：
2. 生存性和安全性
3. 容错设计 
4. 信息亢余和系统备份 

## Chapter 6
### 6.1 软件类型
#### 6.1.1 现货软件
1. 商业现货软件:像超市中商品一样售卖的软件
2. 政府现货软件
3. 工业现货软件
4. 可修改现货软件

#### 6.1.2 可复用软件
1. 企业内部开发,被用于不同的用途
#### 6.1.3 按合同开发的软件
1. 合同软件或客户软件.项目在定义的软件必须遵循要求的同时,还要定义开发过程中的要求和安全问题.
#### 6.1.4 开源软件
1. 同时提供源代码和一些平台上的机器代码.
2. 许多开源软件缺乏相关的文档,更没有质量方面的分析和善意的提醒.
#### 6.1.5 软件类型与质量
### 6.2 软件产品销售模式
#### 6.2.1 软件产品销售行为
1. 为了防止用户一次购买,多次多台机器复制使用,从法律角度约束了软件使用权限----==软件许可证(license)==
1. 许可证是==知识产权(IPR)== 的表达,表示软件产品的使用权益的责任.
2. 许可证描述了软件的使用权限,如使用时间段,地域等以及相关的免责声明.
#### 6.2.2 最终用户协议
1. 是许可证提供者和购买者之间的契约,规定了购买者使用软件的权利
#### 6.2.3 点击同意协议
1. 是互联网中常有的软件协议,在安装过程中,软件用户一旦点击同意协议之后,就不能够再反悔. 
#### 6.2.4 二次开发的皇税协议
1. 设备的软件成本=工具价格+版税x生产的设备个数
#### 6.2.5 开源协议
1. OSI,其基础是开源定义(OSD)
#### 6.2.6 GNU,BSD,MIT协议
1. ==GNU General Public License(GPL)许可证==:
2. ==BSD(Berkeley Software Distribution)开源协议==:
3. ==MIT协议==:最为宽松,唯一的要求是使用开源软件的项目中必须包含被使用开源软件的版权和许可提示,包括许可声明
#### 6.2.7 免许可证软件
1. 是一种宣称了版权,但是不提供许可证的软件.
2. 许多小的脚本程序的发布是没有许可证的.
#### 6.2.8 国际间的软件版权


###  6.3 软件项目采购模式

#### 6.3.1 软件采购和外包形式
1. 最终用户,客户,承包商
2. 软件外包关系分类
	* 简单双边
	* 多个供货商
	* 合作外包
	* 复杂外包
#### 6.3.2 软件采购过程
1. 策划组织和采购策略.评测采购者的目的,开发出进行软件采购的策略
2. 实施组织的软件采购
3. 定义软件需求
4. 识别潜在的供货商
5. 准备合同要求
6. 方案评审,并选择供应商
7. 监督和管理供应商的行为和性能
8. 软件验收
9. 软件运行
#### 6.3.3 软件采购主要问题
1. 

### 6.4 OTS的采购和使用
#### 6.4.1 一般问题
1. 为了表示采用OTS软件的风险和可信赖性,诞生了专用叫法:==血统不确定软件(SOUP)或源产地不清楚软件==
#### 6.4.2 安全性问题
#### 6.4.3 密安性考虑


### 6.5 总结
#### 
#### 
#### 
#### 
## Chapter 7 软件运维与服务过程
### 7.1 引言
### 7.2 软件移交与验收过程
### 7.3 软件支持过程
#### 7.3.1 软件维护与传统产品维护
#### 7.3.2 Lehman定律
#### 7.3.3 维护成本

### 7.4 软件支持过程与活动
#### 7.4.1 软件修改过程
#### 7.4.2 软件支持活动


### 7.5 软件支持方式与能力
#### 7.5.1 软件支持方式与基本要求
#### 7.5.2 针对软件可使用性的支持
#### 7.5.3 针对运行能力的支持


### 7.6 独立的软件支持
#### 7.6.1 软件支持的原则
#### 7.6.2 系统部署前后的支持工作
#### 7.6.3 采购对支持工作的要求


### 7.7 本章小结

### 
#### 
#### 
#### 
#### 


## Heading