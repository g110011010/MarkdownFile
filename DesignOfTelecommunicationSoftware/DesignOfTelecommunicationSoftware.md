---
title: 2017-9-28 
tags: 
author:sf
grammar_cjkRuby: true
---
2017/09/28
### Course 1
1. OSI模型
	1. 物理层:对应实体为网卡,传输数据包
	2. 数据链路层:确定错误识别方法,确定是使用纠错方法还是检错方法. 数据链路层之间确定自己使用的方法.同时定义一个协议向上的接口,两个链路层之间准从共同的协议标准.对于发送的数据,会进行增加校验位等操作确保校验位完整.对于接收的数据,会通过减去校验位等方式还原数据本来的信息.
	3. 网络层:确定了寻找路由的方法,

#### 通讯软件的特点
1. 基于通讯协议或信令系统
2. 运行时间长
3. 基于有限状态机

#### 通讯软件开发课程
#### 2G网络 
1. 基站
1. MSC:移动交换中心
2. VLR:存储在本地开户的号码信息信息
2. HLR:顶层的数据存储,当电话到外地时,由HLR向开户地VLR查找电话信息,并返回信息给所在地VLR,手机连接入外地基站时,会向HLR报告自己当前连入交换机的位置
3. 被叫用户有唯一的一个号码,建立通话首先要确定被叫用户在哪一个交换机上,主叫号码发出请求消息

### Course 3 
#### 什么是通讯协议
1. ==通讯协议==：在计算机网络中，为了两个或多个通讯实体之间准确

#### 网络协议体系 
# Chapter 1 绪论
## 1.通讯与通讯协议
1. ==通讯==：就是互通信息，是利用电子技术在两个或者多个实体之间传递信息
2. ==通讯协议==：为了保证信息能够准确的完整的交换，必须对信息交换的顺序，条件以及信息的格式和内容进行约定，这一整套约定就称为通讯协议。
## 2.通讯软件的概念及特点
1. ==通讯软件==：凡是用来实现两个或者多个实体之间交换信息的软件都能称为通讯软件。通讯软件主要有两大类：==电信软件==和==计算机通讯软件==
## 3.通讯软件开发过程
### 1. 需求分析
1. 解决的是应该做什么的问题
2. 解决的是如何做的问题
### 2. 概要设计
### 3. 详细设计
## 4.通讯协议开发过程
1. 开发协议有两个过程：
	* 为了满足新的通讯需求，研发新的协议
	* 在某一个特定的应用场景下，实现某一个已经成熟的协议

2. 新的协议的开发过程包括：
	* 协议环境分析
	* 协议功能设计
	* 协议元素设计
	* 形成协议文本
	* 协议描述
	* 协议验证

3. 在特定环境下实现一个已经成熟的协议的开发过程包括：
	* 协议分析
	* 协议设计
	* 协议验证
	* 协议实现
	* 协议测试
	* 协议维护
	> 实现某一个具体协议的过程基本上涵盖了开发新协议的过程
# Chapter 2 协议分析技术
1. 协议分析包括两大部分：==协议环境分析==和==协议功能分析==
## 1. 协议环境分析
> n层用户对n层协议提供的服务可以提出的要求可以归结为以下几个方面
### 1. 用户要求
1. **连接管理**：n层用户可以要求n层协议提供==有连接服务==、==无连接服务==和==永久连接服务==，并要求n层协议负责连接的建立、释放、作废、复位、恢复等管理工作。
2. **广播和组播**：n层用户可以要求n层协议提供广播或组播功能。
	* ==广播==：一个n层用户发出的数据报，在同一个网络中的其他用户均能够接收到。
	* ==组播==：一个或多个n层用户发出的数据报，在网络中有一组用户可以接受到该数据报，每一个用户可以加入或退出该组。

3. **服务证实功能**：n层用户通过服务原语得到n层协议提供的服务。服务原语由服务动作和原语类型两个部分组成。原语类型有四个。服务类型有三种。
	* 服务动作：代表用户的功能需求，如连接建立、数据传输、连接释放等
	* 原语类型：
		* request（请求）
		* indication（指示）
		* response（响应）
		* confirm（证实）

	* 证实方式：服务原语的交换时序称为服务证实方式
		* 用户证实方式
			1.  需要四个服务原语
			2.  要求对端用户做出响应，发端用户在得到证实之前不会发送心得数据报，因而通讯效率低。

		* 协议证实方式
			1. 需要三条服务原语，不需要response
			2. 不需要对端用户响应，但是n层协议保证用户的请求已经提交给对端用户（@sf dk）
		* 无证实方式：
			1. 需要原语request和indication
			2. 不能保证用户的请求被提交给了对端的用户，但是支持用户之间采用异步方式进行通讯，通讯效率可以大大提高

		* 其他三种特殊验证方式

	* 
### 2. 通道性质
### 3. 工作模式
## 2. 协议功能分析
### 1. 连接控制管理
### 2. 通讯方式管理
### 3. 数据发送、接收管理
1. n层用户与n层协议之间传递的数据称为==服务数据单元（SDU）==，而n层协议实体之间传递的数据称为==协议数据单元（PDU）==
### 4. 数据安全与完整性
### 5. 发送/接收控制
### 6. 中继
### 7. 路由选择
### 8. 通道管理
### 9. 其他功能

# Chapter 4 协议描述技术
### 4.1 MSC概述
1. ＭＳＣ是一种形式语言，用来描述多个实体之间和实体与环境之间的消息交互顺序．
#### 4.1.1 MSC的特点
1. MSC图是一种消息跟踪语言.MSC描述通信及其他事件的发生的顺序,同时也可以表示对数值传递和事件定时的限定
2. MSC是一种"场景语言".每张MSC图只描述系统在某种特殊情况下的通信行为,不同的场景需要不同的MSC图来表示.
3. 其它,见课本
#### 4.1.2 MSC的实体类型
1. MSC文档
2. MSC图:与MSC文档称为"视见域"
3. 实例(instance):在一个视见域内,属于同一种试题类型的两个实体不能使用相同的名称.在不同的MSC图,使用相同的名称表示同一个实体. 
4. 状态(condition)
5. 定时器(timer)
6. 消息(message)
7. 通道(gate)
8. 变量(variable)
#### 4.1.3 定义图形文法的符号说明
* `<>`表示括号内的符号为非终结符,即还需要进一步定义
* `{}` 表示括号内的内容有关联性
* `<>*`表示括号内的内容是可选的,可以为0或者任意多次
* `<>+`表示括号内的内容是必选的,可以为1或者任意多次
* `::=`为定义符,定义符左侧为非终极符,右侧为终结符和"/"或终结符组成的符号串.
* `|`为"或"符,该符号两边的内容为并列关系

> * 非终结符最终都要使用终结符来定义.终结符包括MSC图中的关键字,各种标识符,名称,各种图形符号.

**说明句法结构的词组**
* ==contains==`<area1> contains <area2>表示<area1>包含<area2>,包含的意义体现在几何图形上,也反映在逻辑关系上
* ==is followed by==` 

### ４.2 ＭＳＣ基础
#### 4.2.1　ＭＳＣ图
#### 4.2.2 实例
#### 4.2.3 消息
#### 4.2.4 条件
#### 4.2.5 定时器
#### 4.2.6 动作
#### 4.2.7 进程创建
#### 4.2.8 进程终止
#### 4.2.9 方法调用与回复
#### 4.2.10 环境与通道

### ４.3 MSC结构概念
#### 4.3.1 并发
#### 4.3.2 MSC引用
#### 4.3.3 线内表达式

### ４.4 高级MSC概念
### ４.5 MSC文档
### ４.6 MSC应用举例
#### ４.6.1 硬件结构与工作原理
#### ４.6.2 需求分析
#### ４.6.3 软件结构设计
#### ４.6.4 消息定义
#### ４.6.5 消息交互图


## Chapter 5 规范说明和描述语言SDL
1. SDL的特点是既可以用来说明一个系统所应该具有的行为,也可以用来描述一个系统实际具有的行为.
### 5.1 系统行为
1. SDL把系统划分为两个部分:ＳＤＬ系统和环境.SDL系统设计者关注的对象,用SDL语言来说明和描述
2. SDL描述系统行为的基础是扩展有限状态自动机.
3. SDL中的每一个进程都是一个有限状态机 
### 5.2 SDL系统结构
1. 在SDL系统中,进程实例是基本单位,系统行为主要用进程实例来描述.具有相同特性的进程实例构成进程集,
2. 进程集与进程集之间可以利用信号来交换信息.进程集之间用信道相连,交互的信号都通过信道来传递.
3. 功能相似的进程集构成功能块,系统则由若干功能块组成,功能块之间也用信道相连. 
4. SDL系统由系统/功能块/和进程三个层次的实体组成.系统由功能块组成,功能块可以由功能块或者进程组成.
### 5.3 SDL语法
#### 5.3.1 包
#### 5.3.2 系统
#### 5.3.3 功能块
#### 5.3.4 进程
#### 5.3.5 过程
#### 5.3.6 远程过程
#### 5.3.7 信号与信道

### 5.4 系统行为描述
#### 5.4.1 开始域
#### 5.4.2 状态域
#### 5.4.3 触发事件
#### 5.4.4 保存域
#### 5.4.5 输出域
#### 5.4.6 创建进程实例
#### 5.4.7 任务域
#### 5.4.8 过程调用
#### 5.4.9 分支域
#### 5.4.10 连接域
#### 5.4.11 图形符号连接关系

### 5.5 定时操作
### 5.6 正文扩展与注释
### 5.7 数据定义
#### 5.7.1 预定义数据类型
#### 5.7.2 定义新的数据类型
#### 5.7.3 定义同义类型和同义词
#### 5.7.4 变量定义与使用
#### 5.7.5 远端变量

### 5.8 面向对象的概念
#### 5.8.1 进程类
#### 5.8.2 功能块类
#### 5.8.3 系统类
#### 5.8.4 上下文参数
#### 5.8.5 类的特殊处理



## Heading